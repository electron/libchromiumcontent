#!/usr/bin/env python

import argparse
import contextlib
import errno
import fnmatch
import glob
import os
import re
import shutil
import subprocess
import sys
import zipfile

from lib.config import get_configuration, get_output_dir


SOURCE_ROOT = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
DIST_DIR = os.path.join(SOURCE_ROOT, 'dist')
SRC_DIR = os.path.join(SOURCE_ROOT, 'src')

# Almost everything goes into the main zip file...
MAIN_DIR = os.path.join(DIST_DIR, 'main')
DIST_SRC_DIR = os.path.join(MAIN_DIR, 'src')

TARGET_PLATFORM = {
  'cygwin': 'win32',
  'darwin': 'darwin',
  'linux2': 'linux',
  'win32': 'win32',
}[sys.platform]

SHARED_LIBRARY_SUFFIX = {
  'darwin': 'dylib',
  'linux': 'so',
  'win32': 'dll',
}[TARGET_PLATFORM]
STATIC_LIBRARY_SUFFIX = {
  'darwin': 'a',
  'linux': 'a',
  'win32': 'lib',
}[TARGET_PLATFORM]

COMPONENTS = ['static_library', 'shared_library']
BINARIES = {
  'all': [
    'content_shell.pak',
    'icudtl.dat',
    'natives_blob.bin',
    'snapshot_blob.bin',
    os.path.join('gen', 'blink', 'public', 'resources', 'blink_image_resources_200_percent.pak'),
    os.path.join('gen', 'content', 'app', 'resources', 'content_resources_200_percent.pak'),
    os.path.join('gen', 'ui', 'resources', 'ui_resources_200_percent.pak'),
    os.path.join('gen', 'ui', 'resources', 'ui_resources_300_percent.pak'),
    os.path.join('gen', 'ui', 'views', 'resources', 'views_resources_200_percent.pak'),
    os.path.join('gen', 'ui', 'views', 'resources', 'views_resources_300_percent.pak'),
  ],
  'darwin': [
    'chromedriver',
    'mksnapshot',
    'libffmpeg.dylib',
    'libdevtools_discovery.a',
    'libdevtools_http_handler.a',
    'libhttp_server.a',
    'libdesktop_capture.a',
    'libdesktop_capture_differ_sse2.a',
    'librtc_base.a',
    'librtc_base_approved.a',
    'libwebrtc_common.a',
    'libyuv.a',
    'libsystem_wrappers.a',
    'libcdm_renderer.a',
    'libsecurity_state.a',
  ],
  'linux': [
    'chromedriver',
    'mksnapshot',
    'libosmesa.so',
    'libgtk2ui.a',
    'libdevtools_discovery.a',
    'libdevtools_http_handler.a',
    'libhttp_server.a',
    'libdesktop_capture.a',
    'libdesktop_capture_differ_sse2.a',
    'librtc_base.a',
    'librtc_base_approved.a',
    'libwebrtc_common.a',
    'libyuv.a',
    'libsystem_wrappers.a',
    'libcdm_renderer.a',
    'libsecurity_state.a',
    os.path.join('lib', 'libffmpeg.so'),
  ],
  'win32': [
    'chromedriver.exe',
    'd3dcompiler_47.dll',
    'ffmpeg.dll',
    'ffmpeg.dll.lib',
    'libEGL.dll',
    'libGLESv2.dll',
    'libyuv.lib',
    'mksnapshot.exe',
    os.path.join('gen', 'ui', 'resources', 'ui_unscaled_resources.rc'),
    os.path.join('obj', 'base', 'base_static.cc.pdb'),
    os.path.join('obj', 'base', 'base_static.lib'),
    os.path.join('obj', 'components', 'devtools_discovery.cc.pdb'),
    os.path.join('obj', 'components', 'devtools_discovery.lib'),
    os.path.join('obj', 'components', 'devtools_http_handler.cc.pdb'),
    os.path.join('obj', 'components', 'devtools_http_handler.lib'),
    os.path.join('obj', 'components', 'cdm_renderer.cc.pdb'),
    os.path.join('obj', 'components', 'cdm_renderer.lib'),
    os.path.join('obj', 'components', 'security_state.cc.pdb'),
    os.path.join('obj', 'components', 'security_state.lib'),
    os.path.join('obj', 'content', 'sandbox_helper_win.cc.pdb'),
    os.path.join('obj', 'content', 'sandbox_helper_win.lib'),
    os.path.join('obj', 'net', 'http_server.cc.pdb'),
    os.path.join('obj', 'net', 'http_server.lib'),
    os.path.join('obj', 'pdf', 'pdf.cc.pdb'),
    os.path.join('obj', 'pdf', 'pdf.lib'),
    os.path.join('obj', 'ppapi', 'ppapi_cpp_objects.cc.pdb'),
    os.path.join('obj', 'ppapi', 'ppapi_cpp_objects.lib'),
    os.path.join('obj', 'ppapi', 'ppapi_cpp.cc.pdb'),
    os.path.join('obj', 'ppapi', 'ppapi_cpp.lib'),
    os.path.join('obj', 'ppapi', 'ppapi_internal_module.cc.pdb'),
    os.path.join('obj', 'ppapi', 'ppapi_internal_module.lib'),
    os.path.join('obj', 'sandbox', 'sandbox.cc.pdb'),
    os.path.join('obj', 'sandbox', 'sandbox.lib'),
    os.path.join('obj', 'third_party', 'libjpeg_turbo', 'libjpeg.c.pdb'),
    os.path.join('obj', 'third_party', 'libjpeg_turbo', 'libjpeg.lib'),
    os.path.join('obj', 'third_party', 'libyuv', 'libyuv.cc.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'pdfium.cc.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'pdfium.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'fdrm.cc.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'fdrm.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'formfiller.cc.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'formfiller.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'fpdfapi.cc.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'fpdfapi.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'fpdfdoc.cc.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'fpdfdoc.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'fpdftext.cc.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'fpdftext.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'fxcodec.cc.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'fxcodec.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'fxcrt.cc.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'fxcrt.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'fxedit.cc.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'fxedit.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'fxge.cc.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'fxge.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'javascript.cc.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'javascript.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'pdfwindow.cc.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'pdfwindow.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'third_party', 'bigint.cc.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'third_party', 'bigint.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'third_party', 'fx_agg.cc.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'third_party', 'fx_agg.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'third_party', 'fx_freetype.c.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'third_party', 'fx_freetype.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'third_party', 'fx_lcms2.c.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'third_party', 'fx_lcms2.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'third_party', 'fx_libopenjpeg.c.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'third_party', 'fx_libopenjpeg.lib'),
    os.path.join('obj', 'third_party', 'pdfium', 'third_party', 'fx_zlib.c.pdb'),
    os.path.join('obj', 'third_party', 'pdfium', 'third_party', 'fx_zlib.lib'),
    os.path.join('obj', 'third_party', 'webrtc', 'base', 'rtc_base.cc.pdb'),
    os.path.join('obj', 'third_party', 'webrtc', 'base', 'rtc_base.lib'),
    os.path.join('obj', 'third_party', 'webrtc', 'base', 'rtc_base_approved.cc.pdb'),
    os.path.join('obj', 'third_party', 'webrtc', 'base', 'rtc_base_approved.lib'),
    os.path.join('obj', 'third_party', 'webrtc', 'modules', 'desktop_capture.cc.pdb'),
    os.path.join('obj', 'third_party', 'webrtc', 'modules', 'desktop_capture.lib'),
    os.path.join('obj', 'third_party', 'webrtc', 'modules', 'desktop_capture_differ_sse2.cc.pdb'),
    os.path.join('obj', 'third_party', 'webrtc', 'modules', 'desktop_capture_differ_sse2.lib'),
    os.path.join('obj', 'third_party', 'webrtc', 'system_wrappers', 'system_wrappers.cc.pdb'),
    os.path.join('obj', 'third_party', 'webrtc', 'system_wrappers', 'system_wrappers.lib'),
    os.path.join('obj', 'third_party', 'webrtc', 'webrtc_common.cc.pdb'),
    os.path.join('obj', 'third_party', 'webrtc', 'webrtc_common.lib'),
  ],
}

ARCH_BLACKLIST = {
  'arm': [
    'libdesktop_capture_differ_sse2.a',
  ],
  'x64': [
    'libprotobuf_full_do_not_use.a',
    'libprotoc_lib.a',
  ],
  'ia32': [
  ],
}

SYMBOLS = {
  'darwin': [
    # OS X has a more complicated symbol creation process. See
    # create_dsym() and copy_symbols().
  ],
  'linux': [
    'libosmesa.so.dbg',
  ],
  'win32': [
    'libGLESv2.dll.pdb',
  ],
}

# Emperically determined to be required by client apps.
INCLUDE_DIRS = [
  'base',
  'build',
  'cc',
  'chrome/browser/ui/libgtk2ui',
  'components/cdm',
  'components/component_updater',
  'components/devtools_discovery',
  'components/devtools_http_handler',
  'components/display_compositor',
  'components/os_crypt',
  'components/prefs',
  'components/security_state',
  'components/update_client',
  'content/browser',
  'content/common',
  'content/public',
  'content/renderer',
  'crypto',
  'device',
  'ipc',
  'gin',
  'gpu',
  'media',
  'mojo',
  'net',
  'pdf',
  'printing',
  'ppapi',
  'sandbox',
  'services',
  'skia',
  'storage',
  'testing',
  'third_party/boringssl',
  'third_party/khronos',
  'third_party/WebKit/Source/platform',
  'third_party/WebKit/Source/wtf',
  'third_party/WebKit/public',
  'third_party/libyuv/include',
  'third_party/webrtc',
  'third_party/icu/source',
  'third_party/mojo/src/mojo/public',
  'third_party/skia',
  'third_party/widevine',
  'third_party/wtl/include',
  'ui',
  'url',
  'v8/include',
  'webkit',
] + {
  'darwin': [],
  'linux': [
    'dbus',
    'third_party/speech-dispatcher',
  ],
  'win32': [],
}[TARGET_PLATFORM]
GENERATED_INCLUDE_DIRS = [
  'content',
  'mojo',
  'media',
  'net',
  'third_party/WebKit',
  'ui',
  'url',
  'services',
  'skia',
]
OTHER_HEADERS = [
  'content/common/content_export.h',
  'ui/events/keycodes/dom/dom_key_data.inc',
  'ui/events/keycodes/dom/keycode_converter_data.inc',
]
OTHER_SOURCES = [
]
OTHER_DIRS = [
  os.path.join('ui', 'resources', 'cursors'),
]


def main():
  args = parse_args()
  target_arch = args.target_arch

  # Some libraries are not available for certain arch.
  for lib in ARCH_BLACKLIST[target_arch]:
    if lib in BINARIES[TARGET_PLATFORM]:
      BINARIES[TARGET_PLATFORM].remove(lib)

  rm_rf(DIST_DIR)
  os.makedirs(DIST_DIR)

  for component in COMPONENTS:
    if args.component == 'all' or args.component == component:
      output_dir = os.path.join(SRC_DIR, get_output_dir(target_arch, component))
      copy_binaries(target_arch, component, output_dir)
      copy_generated_sources(target_arch, component, output_dir)
      copy_locales(target_arch, component, output_dir)

  copy_ffmpeg(target_arch)
  copy_sources()
  generate_licenses()
  if not args.no_zip:
    create_zip()


def parse_args():
  parser = argparse.ArgumentParser(description='Create distribution')
  parser.add_argument('-t', '--target_arch', default='x64', help='x64 or ia32')
  parser.add_argument('-c', '--component', default='all',
                      help='static_library or shared_library or all')
  parser.add_argument('--no_zip', action='store_true',
                      help='Do not create zip distribution')
  return parser.parse_args()


def copy_with_blacklist(target_arch, src, dest):
  if os.path.basename(src) in ARCH_BLACKLIST[target_arch]:
    return
  shutil.copy2(src, dest)


def copy_binaries(target_arch, component, output_dir):
  config_dir = os.path.join(output_dir, get_configuration(target_arch))
  target_dir = os.path.join(MAIN_DIR, component)
  mkdir_p(target_dir)

  for binary in BINARIES['all'] + BINARIES[TARGET_PLATFORM]:
    copy_with_blacklist(target_arch, os.path.join(config_dir, binary), target_dir)

  if component == 'shared_library':
    match = '*.{0}'.format(SHARED_LIBRARY_SUFFIX)
  else:
    match = '*.{0}'.format(STATIC_LIBRARY_SUFFIX)

  if TARGET_PLATFORM == 'darwin':
    # out/Release/*.{dll,lib}
    for library in glob.glob(os.path.join(config_dir, match)):
      copy_with_blacklist(target_arch, library, target_dir)

  if TARGET_PLATFORM == 'win32':
    if component == 'shared_library':
      # out/Release/*.dll(.lib)
      for dll in glob.glob(os.path.join(config_dir, '*.dll')):
        lib = dll + '.lib'
        if os.path.exists(lib):
          copy_with_blacklist(target_arch, dll, target_dir)
          copy_with_blacklist(target_arch, lib, target_dir)
    else:
      # On Windows static libraries are placed under subdirs under "obj".
      for root, _, filenames in os.walk(os.path.join(config_dir, 'obj')):
        # out/Release/obj/**/*.lib
        for filename in fnmatch.filter(filenames, '*.lib'):
          copy_with_blacklist(target_arch, os.path.join(root, filename), target_dir)
        # out/Release/obj/**/*.pdb
        for filename in fnmatch.filter(filenames, '*.pdb'):
          copy_with_blacklist(target_arch, os.path.join(root, filename), target_dir)

  if TARGET_PLATFORM == 'linux':
    if component == 'shared_library':
      # out/Release/lib/*.so
      for library in glob.glob(os.path.join(config_dir, 'lib', '*.so')):
        copy_with_blacklist(target_arch, library, target_dir)
    else:
      # out/Release/*.a
      for library in glob.glob(os.path.join(config_dir, '*.a')):
        copy_with_blacklist(target_arch, library, target_dir)

  if TARGET_PLATFORM in ['linux', 'darwin']:
    # Strip the copied binaries since they contain quite large debug info.
    for binary in BINARIES[TARGET_PLATFORM]:
      run_strip(target_arch, os.path.join(target_dir, os.path.basename(binary)))
    # We do not need debug info in "shared_library" build, since it will only
    # be used for Release build.
    if component == 'shared_library':
      for library in glob.glob(os.path.join(target_dir, match)):
        run_strip(target_arch, library)


def copy_generated_sources(target_arch, component, output_dir):
  config = get_configuration(target_arch)
  target_dir = os.path.join(MAIN_DIR, component)
  for include_path in GENERATED_INCLUDE_DIRS:
    copy_headers(include_path,
                 relative_to=os.path.join(output_dir, config, 'gen'),
                 destination=os.path.join(target_dir, 'gen'))

def copy_locales(target_arch, component, output_dir):
  config = get_configuration(target_arch)
  target_dir = os.path.join(MAIN_DIR, component, 'locales')
  mkdir_p(target_dir)
  src_dir = os.path.join(output_dir, config, 'gen', 'content', 'app', 'strings')
  for src_file in glob.glob(os.path.join(src_dir, 'content_strings_*.pak')):
    filename = os.path.basename(src_file)
    new_name = re.sub('content_strings_', '', filename)
    shutil.copy2(src_file, os.path.join(target_dir, new_name))

def copy_sources():
  for include_path in INCLUDE_DIRS:
    copy_headers(include_path, relative_to=SRC_DIR, destination=DIST_SRC_DIR)

  for path in OTHER_HEADERS + OTHER_SOURCES:
    copy_source_file(os.path.join(SRC_DIR, path), relative_to=SRC_DIR,
                     destination=DIST_SRC_DIR)

  for path in OTHER_DIRS:
    copy_dir(path, relative_to=SRC_DIR, destination=DIST_SRC_DIR)


def copy_ffmpeg(target_arch):
  output_dir = os.path.join(SRC_DIR,
                            get_output_dir(target_arch, 'ffmpeg'),
                            get_configuration(target_arch))
  if TARGET_PLATFORM == 'darwin':
    binary = 'libffmpeg.dylib'
  elif TARGET_PLATFORM == 'linux':
    binary = os.path.join('lib', 'libffmpeg.so')
  elif TARGET_PLATFORM == 'win32':
    binary = 'ffmpeg.dll'

  target_dir = os.path.join(MAIN_DIR, 'ffmpeg')
  mkdir_p(target_dir)
  shutil.copy2(os.path.join(output_dir, binary), target_dir)



def copy_headers(relative_path, relative_to, destination):
  abs_path = os.path.join(relative_to, relative_path)
  for dirpath, dirnames, filenames in os.walk(abs_path):
    for filename in filenames:
      if os.path.splitext(filename)[1] != '.h':
        continue
      copy_source_file(os.path.join(dirpath, filename), relative_to=relative_to, destination=destination)


def copy_source_file(absolute_path, relative_to, destination):
  relative_path = os.path.relpath(absolute_path, start=relative_to)
  final_path = os.path.join(destination, relative_path)
  mkdir_p(os.path.dirname(final_path))
  shutil.copy2(absolute_path, final_path)


def copy_dir(relative_path, relative_to, destination):
  abs_path = os.path.join(relative_to, relative_path)
  for dirpath, dirnames, filenames in os.walk(abs_path):
    for filename in filenames:
      copy_source_file(os.path.join(dirpath, filename), relative_to=relative_to, destination=destination)


def run_strip(target_arch, filename):
  # Static libraries are not stripped because it would remove
  # all the symbols in it.
  if filename.endswith('.a'):
    return
  if TARGET_PLATFORM == 'linux':
    flags = []
  else:
    flags = ['-x', '-S']
  if target_arch == 'arm' and filename.endswith(('.so', 'chromedriver')):
    strip = 'arm-linux-gnueabihf-strip'
  else:
    strip = 'strip'
  subprocess.check_call([strip] + flags + [filename])


def run_ar_combine(filename, target_dir):
  target = os.path.join(target_dir, os.path.basename(filename))
  ar_combine = os.path.join(SOURCE_ROOT, 'tools', 'linux', 'ar-combine.sh')
  subprocess.check_call([ar_combine, '-o', target, filename])


def generate_licenses():
  file_template = os.path.join(SOURCE_ROOT, 'resources', 'about_credits.tmpl')
  entry_template = os.path.join(SOURCE_ROOT, 'resources',
                                'about_credits_entry.tmpl')
  licenses_py = os.path.join(SOURCE_ROOT, 'tools', 'licenses.py')
  target = os.path.join(MAIN_DIR, 'LICENSES.chromium.html')
  subprocess.check_call([sys.executable, licenses_py, 'credits', target,
                         '--file-template', file_template,
                         '--entry-template', entry_template])


def create_zip():
  print 'Zipping shared_library builds...'
  p = os.path.join(SOURCE_ROOT, 'libchromiumcontent.zip')
  make_zip(MAIN_DIR, ['src', 'ffmpeg', 'shared_library'], ['LICENSES.chromium.html'], p)
  print 'Zipping static_library builds...'
  p = os.path.join(SOURCE_ROOT, 'libchromiumcontent-static.zip')
  make_zip(MAIN_DIR, ['static_library'], [], p)


def make_zip(src, dirs, files, target):
  safe_unlink(target)
  with scoped_cwd(src):
    zip_file = zipfile.ZipFile(target, 'w', zipfile.ZIP_DEFLATED,
                               allowZip64=True)
    for dirname in dirs:
      for root, _, filenames in os.walk(dirname):
        for f in filenames:
          zip_file.write(os.path.join(root, f))
    for f in files:
      zip_file.write(f)
    zip_file.close();


def mkdir_p(path):
  try:
    os.makedirs(path)
  except OSError as e:
    if e.errno != errno.EEXIST:
      raise


def rm_rf(path):
  try:
    shutil.rmtree(path)
  except OSError as e:
    if e.errno != errno.ENOENT:
      raise


def safe_unlink(path):
  try:
    os.unlink(path)
  except OSError as e:
    if e.errno != errno.ENOENT:
      raise


def is_newer(destination, source):
  return os.path.exists(destination) and \
    os.path.getmtime(destination) > os.path.getmtime(source)


@contextlib.contextmanager
def scoped_cwd(path):
  cwd = os.getcwd()
  os.chdir(path)
  try:
    yield
  finally:
    os.chdir(cwd)


if __name__ == '__main__':
  sys.exit(main())
